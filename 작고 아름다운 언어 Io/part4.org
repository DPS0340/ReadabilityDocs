* 작고 아름다운 언어 Io, Part 4: 동시성 프로그래밍 
:PROPERTIES:
:TOC:      :include descendants
:END:
2010년 7월 27일

:CONTENTS:
- [[#행위자actors][행위자(actors)]]
- [[#퓨처][퓨처]]
- [[#코루틴][코루틴]]
- [[#비결정적-함수와-상태가-있는-객체][비결정적 함수와 상태가 있는 객체]]
- [[#가능성이-많지만-아직은-아쉬운-언어][가능성이 많지만 아직은 아쉬운 언어]]
:END:

지난 몇 년간 컴퓨터 프로그래밍에서 가장 큰 화두 중 하나는 바로 동시성(concurrency) 문제라고 할 수 있다. [[https://www.erlang.org/][Erlang]]처럼 만들어진 지 오래된 언어가 동시성 문제에 대해 좋은 실마리를 주기 때문에 뒤늦게 재조명받기도 했고, [[https://clojure.org/][Clojure]], [[https://www.scala-lang.org/][Scala]] 등 최근에 만들어져 인기를 얻고 있는 언어들은 하나같이 모두 동시성 문제에 대해 각자의 좋은 해결책을 제시하고 있다. 그렇다면 Io는 어떨까?

** 행위자(actors)
Io의 동시성 프로그래밍(concurrent programming)은 공식 문서에 나온 예제만 보고도 쉽게 이해할 수 있을 정도로 간단하다. 보통 우리가 짜는 코드는 동기적으로 작동한다. 앞 문장이 모든 것을 끝마칠 때까지 기다린 다음에 다음 문장이 순서대로 처리된다.
#+BEGIN_SRC io
receiver doSomething
#+END_SRC

위 예제는 동기적인 메시징의 예다(Io에서는 저러한 표현식 모두를 메시지라고 한다). =doSomething= 메서드가 제 할 일을 끝내면 바로 다음에 있는 문장이 이어서 실행될 것이다. 저 메서드가 끝날 때까지 기다리지 않고 다음 문장을 바로 진행하려면 어떻게 해야 할까?
#+BEGIN_SRC io
receiver @doSomething
#+END_SRC

매우 간단하다. 메서드 이름 앞에 =@= 문자를 붙이면 된다. 참고로 저 기호 역시 Io의 문법적인 부분은 아니다. 단지 Object에 =@= 이라는 이름이 슬롯이 있을 뿐이다. 저 문장이 어떻게 파싱되는지 궁금하다면 REPL에서 아래와 같이 확인해볼 수 있다.
#+BEGIN_SRC io
Io> message(receiver doSomething)
==> receiver doSomething
Io> message(receiver @doSomething)
==> receiver @(doSomething)
#+END_SRC

인자를 넣고 싶으면 인자를 넣을 수도 있다.
#+BEGIN_SRC io
receiver doSomething(arg, arg2)   // 동기적으로 실행
receiver @doSomething(arg, arg2)  // 비동기적으로 실행
#+END_SRC

굉장히 간단하다.

** 퓨처
그런데 위 예제의 =doSomething= 메서드가 어떤 값을 반환하는 함수라면 결과 값을 어떻게 비동기적으로 받아서 처리할 수 있을까? 물론 동기적으로 처리한다면 결과가 나올 때까지 다 기다리기 때문에 결과 값을 처리할 수 있지만, 비동기적으로 처리할 경우 어느 시점까지는 결과 값이 준비되지 않기 때문에 별도로 처리해줄 필요가 있다.
#+BEGIN_SRC io
result := receiver doSomething(arg, arg2)
#+END_SRC

위와 같은 동기적인 문장은 아래처럼 바꿀 수 있다.
#+BEGIN_SRC io
futureResult := receiver @doSomething(arg, arg2)
#+END_SRC

=futureResult= 변수에는 미래의 결과 값이 들어간다. 조금 이상하게 생각될 수도 있는데, Io에서는 이것을 이름 그대로 퓨쳐(future)라고 소개하고 있다. 글만 가지고는 이해하기 힘드니 다음 예를 보자.
#+BEGIN_SRC io
Io> addSlowly := method(a, b, System sleep(5); a + b)
==> method(a, b,
    System sleep(5); a + b
)
Io> @addSlowly(10, 20)
==> 30
#+END_SRC

REPL에서 위와 같이 =@addSlowly(10, 20)= 을 실행해보면 동기적으로 결과가 나올 것이다. =System sleep(5)= 를 해뒀기 때문에 약 5초를 기다린 다음 =30= 이라는 결과 객체가 나온다. 이는 퓨쳐 객체가 조금이라도 건들면 그 순간에 블로킹(blocking)이 되기 때문에 나타나는 현상이다. 제대로 확인하려면 퓨쳐를 바로 보려고 하지 말고 특정 변수 등에 담아서 관찰해야 한다(REPL은 객체를 표시하기 위해 내부적으로 객체에 =println= 메시지를 보낸다).

단, 이 때 주의할 것이 하나 있다. 대입문 역시 그 자신이 담으려는 값을 그대로 반환하는 표현식이므로 평가되지 않도록 조심해서 관찰해야 한다. REPL은 한 줄에 세미콜론을 써서 여러 문장을 쓸 수 있는데, 그러면 맨 마지막 문장의 결과만 출력된다. 대입문 바로 다음에 =nil= 따위를 써서 퓨쳐의 출력을 막을 수 있다.
#+BEGIN_SRC io
Io> f := @addSlowly(10, 20); nil
==> nil
#+END_SRC

이번에는 확실히 다음 프롬프트가 곧바로 표시되는 것을 알 수 있다. 이 상태에서 다른 작업을 동시에 하다가, =f= 결과 값이 필요해지는 순간에 사용하면 알아서 평가된다.
#+BEGIN_SRC io
Io> f
==> 30
#+END_SRC

=f= 를 사용하려는 순간에도 아직 결과 값이 준비되지 않았다면, 블로킹되어 나머지 연산이 마무리될 때까지 마저 기다리고 나서 결과 값이 나오게 된다.

여기까지 보면 퓨쳐는 완전히 투명(transparent)해 보이며 실제로 Io 문서를 보면 퓨쳐는 투명하다고 설명되어 있다. 하지만 이것은 언어 구현에서 특수하게 처리한 부분은 아니며, 실제로는 =FutureProxy= 형식의 객체가 먼저 반환된다. 이 객체는 어떠한 메시지라도 자신에게 전달되면 즉시 비동기적으로 진행되던 프로세스를 메인 프로세스에 합류(join)시킨다(즉, 블로킹한다). 결과 값이 이미 나온 상태라면 바로 그 결과 값에 대해 메시지를 보낸 값을 반환하며, 준비되지 않은 상태라면 준비될 때까지 마냥 기다린다.

예를 들어 위와 같은 예에서는 =f= 는 프록시 객체이며, REPL 프롬프트에 =f= 라고 입력하면 REPL은 =f= 의 내용을 표시하기 위해 =f println= 메세지를 보낸다. 이 =println= 메시지는 프록시를 통과해 실제 결과 값인 =300= 객체로 전달되어 =300 println= 이 실행되고 프롬프트는 =300= 이라는 결과 값을 볼 수 있게 되는 것이다.

프록시는 메서드 두 개만 구현하는 객체인데, REPL에서 모든 프록시 객체의
원형인 =FutureProxy= 를 입력해보면 자세히 볼 수 있다.
#+BEGIN_SRC io
Io> FutureProxy
==>  FutureProxy_0x9ec9520:
  _forward         = method(...)
  type             = "FutureProxy"
  with             = method(future, ...)
#+END_SRC

핵심은 =_forward= 메서드인데, 이것은 루비의 =method_missing= 이나 파이썬의 =__getattribute__ = 같은 것으로서 모든 메시지는 기본적으로 =_forward= 메서드를 통과한다. 프록시는= _forward= 메서드를 구현하여 자신에게 오는 모든 메시지를 스스로 처리하는 대신 결과 값에 그대로 전달하도록 구현되어 있는 것이다. 따라서 겉으로 보기엔 투명하게 처리된다.


** 코루틴
Io는 동시성을 구현하기 위해 내부적으로 OS 레벨 스레드를 사용하는 대신, 코루틴(coroutine)이라는 사용자 레벨 스레드를 사용한다. 코루틴이라는 말은 서브루틴(subroutine)이라는 낱말과 비교해보면 그 특성을 짐작할 수 있는데, 서브루틴은 자신의 행동이 다 끝난 뒤에 반환(return)되어 직전에 진행 중이던 루틴으로 돌아가게 된다. 이를 구현하기 위해 필연적으로 스택(stack)이 필요하며, 거의 모든 프로그래밍 언어의 추상은 이러한 메타포로 이뤄진다. 반면 코루틴은 진행 중인 코루틴 사이에 깊이의 차이가 없으며 모두 같은 높이에서 마치 배턴을 넘기듯이 진행된다. 서브루틴에서는 =return= 을 만나면 그 자신은 완전히 종료되지만, 코루틴에서는 =yield= 를 만나면 완전히 종료되는 대신 그 위치에서 중단된다.

Io의 비동기 메시지는 각각이 모두 하나의 코루틴으로 실행된다. 만들어진 코루틴은 선입선출되는 =Scheduler= 객체의 대기열(queue)에 들어가며, 완전히 종료된 코루틴은 대기열에서 사라진다. 이 대기열은 =Scheduler yieldingCoros= 메시지를 통해 알 수 있다. 다음 코드는 Io 문서에서 인용한 예제다.
#+BEGIN_SRC io
obj1 := Object clone
obj1 test := method(for(n, 1, 3, n print; yield))
obj2 := obj1 clone
obj1 asyncSend(test); obj2 asyncSend(test)
while(Scheduler yieldingCoros size > 1, yield)
#+END_SRC

위 예제는 항상 =112233= 을 출력한다. =while= 메서드 안쪽에서 =yield= 를 할 때마다 대기열에 있는 순서대로 배턴이 넘어가기 때문에 다른 순서로 진행되지는 않는다.


** 비결정적 함수와 상태가 있는 객체
Io의 간단한 동시성 프로그래밍은 물론 좋은 아이디어이긴 하지만, 막상 실제로 Io로 동시성 프로그래밍을 하려고 하면 문제가 많다.

가장 큰 문제는 표준 라이브러리의 부적절한 설계다. Io 언어 창시자인 Steve Dekorte의 출신 배경인 넥스트(NeXT) 프로그래밍에서 사용되는 오브젝티브-C(Objective-C)의 영향을 받아서인지 몰라도, Io의 표준 라이브러리는 변경 가능한 객체(mutable objects)와 비결정적 함수(non-deterministic functions)로 가득 차 있다. 당연히 이렇게 상태가 변하는 객체로 동시성 프로그래밍을 하면 버그가 생기기 쉬울 것은 자명하다.

그러한 내용으로 트위터(Twitter)에서 Steve Dekorte에게 [[https://twitter.com/hongminhee/status/5330485477][의견]]을 빙자한 야료를 부린 적이 있는데, 그도 대체로 동의한다고 [[http://twitter.com/stevedekorte/status/5330739774][대답]]하기도 했으니 이 문제는 차차 나아질 수 있어 보인다.

** 가능성이 많지만 아직은 아쉬운 언어
연재 목적 자체가 이미 다른 프로그래밍 언어를 알고 있는 독자들에게 Io라는 새로운 프로그래밍 언어의 특별한 부분을 소개해주는 것이었고, 이로서 Io의 특징적인 부분은 대략적으로 모두 언급했다고 생각한다. 이 이상 Io의 실제 사용에 대해 논할 수도 있겠지만 어차피 Io는 실용적으로 사용하기에는 아쉬운 점이 많은 언어다.

Io는 커녕 가장 오래된 프로그래밍 언어이지만 가장 진보적인 프로그래밍 언어이기도 한 리스프(Lisp)도 국내에서는 실무에서 사용되는 것을 보기 굉장히 힘든 편이며, 그보다 좀 더 많이 쓰이는 파이썬이나 루비 등도 여전히 자바 등의 언어에 비하면 실무에서는 아주 미미한 위상을 차지하고 있다.

그러면 어차피 실무에 쓰지도 못할 Io나 리스프 같은 언어를 배워야 할 이유는 뭘까? 가장 큰 이유는 거의 모든 새로운 프로그래밍 패러다임은 필연적으로 리스프 같은 homoiconic하고 최소주의적인 언어에서 실현될 수밖에 없기 때문이다. 굉장히 놀라운 프로그래밍 패러다임 아이디어가 떠올랐다고 해보자. 여러분은 자바 같은 언어 구현을 *직접* 뜯어 고쳐 해석기(parser) 같은 컴파일러 프론트엔드부터 그것을 타깃 언어로 번역하는 컴파일러 백엔드까지 수정해 아이디어를 실험하겠는가?

아마 대부분 공수 문제와 유연성 때문에 리스프의 매크로나 Io의 메시지 기능을 이용해 빠르게 아이디어를 확인하려 할 것이다. 우리가 지난 연재에서 직접 렉시컬 클로저(lexical closure)를 구현했던 것을 기억해보라! MIT의 프로그래밍 수업 교제로 쓰였던 컴퓨터 프로그래밍의 구조와 해석(Structure and Interpretation of Computer Programs)에서는 스킴(Scheme: 리스프의 한 종류) 언어로 스킴을 구현한다. 하지만 우리는 자바로 자바 언어를 개량하기는커녕 그 자신을 구현하기도 벅차다.

폴 그레이엄(Paul Graham)이 그의 에세이 [[http://paulgraham.com/rootsoflisp.html][The Roots Of Lisp]]에서 말한 바와 같이, 모든 프로그래밍 언어는 시간이 지나면서 리스프와 닮아간다. 미래를 보고 싶은 개발자라면 리스프나 Io 같은 언어를 배우는 것에 시간을 투자할 필요가 있다고 생각한다. 아마 지금 Io를 배우면서 얻는 아이디어는 다른 개발자가 10년이나 20년 뒤에야 얻을 아이디어가 될 공산이 크기 때문이다.
